# Expressions within @{...} are not yet supported by the script generator
begin thorn ML_BSSN

# DefaultEvolutionTimelevels -> 2

# EvolutionTimelevels -> 2

# ExtendedKeywordParameters -> {{Name -> "ADMBase::evolution_method", AllowedValues -> {"ML_BSSN"}}, {Name -> "ADMBase::lapse_evolution_method", AllowedValues -> {"ML_BSSN"}}, {Name -> "ADMBase::shift_evolution_method", AllowedValues -> {"ML_BSSN"}}, {Name -> "ADMBase::dtlapse_evolution_method", AllowedValues -> {"ML_BSSN"}}, {Name -> "ADMBase::dtshift_evolution_method", AllowedValues -> {"ML_BSSN"}}}

# GenerateHostCode -> True

# GenerateScript -> True

# IntParameters -> {{Name -> harmonicN, Description -> "d/dt alpha = - f alpha^n K  (harmonic=2, 1+log=1)", Default -> 2}, {Name -> ShiftAlphaPower, Default -> 0}, {Name -> conformalMethod, Description -> "Treatment of conformal factor", AllowedValues -> {{Value -> "0", Description -> "phi method"}, {Value -> "1", Description -> "W method"}}, Default -> 0}, {Name -> fdOrder, Default -> 2, AllowedValues -> {8}}, {Name -> harmonicShift, Description -> "Whether to use the harmonic shift", AllowedValues -> {{Value -> "0", Description -> "Gamma driver shift"}, {Value -> "1", Description -> "Harmonic shift"}}, Default -> 0}}

# KeywordParameters -> {{Name -> "my_initial_data", AllowedValues -> {"ADMBase", "Minkowski"}, Default -> "ADMBase"}, {Name -> "my_initial_boundary_condition", Visibility -> "restricted", AllowedValues -> {"none"}, Default -> "none"}, {Name -> "my_rhs_boundary_condition", Visibility -> "restricted", AllowedValues -> {"none", "static", "radiative"}, Default -> "none"}, {Name -> "my_boundary_condition", AllowedValues -> {"none", "Minkowski"}, Default -> "none"}, {Name -> "calculate_ADMBase_variables_at", Visibility -> "restricted", AllowedValues -> {"MoL_PostStep", "CCTK_EVOL", "CCTK_ANALYSIS"}, Default -> "MoL_PostStep"}, {Name -> "calculate_ADMBase_variables", Visibility -> "restricted", AllowedValues -> {"no", "yes"}, Default -> "yes"}, {Name -> "UseSpatialBetaDriver", Visibility -> "restricted", AllowedValues -> {"no", "yes"}, Default -> "no"}, {Name -> "dt_lapse_shift_method", Description -> "Treatment of ADMBase dtlapse and dtshift", AllowedValues -> {"correct", "noLapseShiftAdvection"}, Default -> "correct"}, {Name -> "apply_dissipation", Description -> "Whether to apply dissipation to the RHSs", AllowedValues -> {"always", "never"}, Default -> "always"}}

# RealParameters -> {{Name -> LapseACoeff, Description -> "Whether to evolve A in time", Default -> 0}, {Name -> harmonicF, Description -> "d/dt alpha = - f alpha^n K   (harmonic=1, 1+log=2)", Default -> 1}, {Name -> AlphaDriver, Default -> 0}, {Name -> ShiftBCoeff, Description -> "Whether to evolve B^i in time", Default -> 1}, {Name -> ShiftGammaCoeff, Default -> 0}, {Name -> BetaDriver, Default -> 0}, {Name -> LapseAdvectionCoeff, Description -> "Factor in front of the lapse advection terms in 1+log", Default -> 1}, {Name -> ShiftAdvectionCoeff, Description -> "Factor in front of the shift advection terms in gamma driver", Default -> 1}, {Name -> MinimumLapse, Description -> "Minimum value of the lapse function", Default -> -1}, {Name -> SpatialBetaDriverRadius, Description -> "Radius at which the BetaDriver starts to be reduced", AllowedValues -> {{Value -> "(0:*", Description -> "Positive"}}, Default -> 1000000000000}, {Name -> SpatialShiftGammaCoeffRadius, Description -> "Radius at which the ShiftGammaCoefficient starts to be reduced", AllowedValues -> {{Value -> "(0:*", Description -> "Positive"}}, Default -> 1000000000000}, {Name -> EpsDiss, Description -> "Dissipation strength", AllowedValues -> {{Value -> "(0:*", Description -> "Positive"}}, Default -> 0}}

# TileSize -> {32, 16, 40}

inherit ADMBase

use cakernel

begin derivatives 
  PDstandardNth u_i = 1/840 * (3 * (u_(i-4)) + -32 * (u_(i-3)) + 168 * (u_(i-2)) + -672 * (u_(i-1)) + 672 * (u_(i)) + -168 * (u_(i+2)) + 32 * (u_(i+3)) + -3 * (u_(i+4))) * (h)**-1
  
  PDstandardNth u_ii = -1/5040 * (14350 * (u_) + 9 * (u_(i-4)) + -128 * (u_(i-3)) + 1008 * (u_(i-2)) + -8064 * (u_(i-1)) + -8064 * (u_(i)) + 1008 * (u_(i+2)) + -128 * (u_(i+3)) + 9 * (u_(i+4))) * (h)**-2
  
  PDstandardNth u_ij = 1/705600 * (9 * (u_(i-4)(j-4)) + -96 * (u_(i-4)(j-3)) + 504 * (u_(i-4)(j-2)) + -2016 * (u_(i-4)(j-1)) + 2016 * (u_(i-4)(j)) + -504 * (u_(i-4)(j+2)) + 96 * (u_(i-4)(j+3)) + -9 * (u_(i-4)(j+4)) + -96 * (u_(i-3)(j-4)) + 1024 * (u_(i-3)(j-3)) + -5376 * (u_(i-3)(j-2)) + 21504 * (u_(i-3)(j-1)) + -21504 * (u_(i-3)(j)) + 5376 * (u_(i-3)(j+2)) + -1024 * (u_(i-3)(j+3)) + 96 * (u_(i-3)(j+4)) + 504 * (u_(i-2)(j-4)) + -5376 * (u_(i-2)(j-3)) + 28224 * (u_(i-2)(j-2)) + -112896 * (u_(i-2)(j-1)) + 112896 * (u_(i-2)(j)) + -28224 * (u_(i-2)(j+2)) + 5376 * (u_(i-2)(j+3)) + -504 * (u_(i-2)(j+4)) + -2016 * (u_(i-1)(j-4)) + 21504 * (u_(i-1)(j-3)) + -112896 * (u_(i-1)(j-2)) + 451584 * (u_(i-1)(j-1)) + -451584 * (u_(i-1)(j)) + 112896 * (u_(i-1)(j+2)) + -21504 * (u_(i-1)(j+3)) + 2016 * (u_(i-1)(j+4)) + 2016 * (u_(i)(j-4)) + -21504 * (u_(i)(j-3)) + 112896 * (u_(i)(j-2)) + -451584 * (u_(i)(j-1)) + 451584 * (u_(i)(j)) + -112896 * (u_(i)(j+2)) + 21504 * (u_(i)(j+3)) + -2016 * (u_(i)(j+4)) + -504 * (u_(i+2)(j-4)) + 5376 * (u_(i+2)(j-3)) + -28224 * (u_(i+2)(j-2)) + 112896 * (u_(i+2)(j-1)) + -112896 * (u_(i+2)(j)) + 28224 * (u_(i+2)(j+2)) + -5376 * (u_(i+2)(j+3)) + 504 * (u_(i+2)(j+4)) + 96 * (u_(i+3)(j-4)) + -1024 * (u_(i+3)(j-3)) + 5376 * (u_(i+3)(j-2)) + -21504 * (u_(i+3)(j-1)) + 21504 * (u_(i+3)(j)) + -5376 * (u_(i+3)(j+2)) + 1024 * (u_(i+3)(j+3)) + -96 * (u_(i+3)(j+4)) + -9 * (u_(i+4)(j-4)) + 96 * (u_(i+4)(j-3)) + -504 * (u_(i+4)(j-2)) + 2016 * (u_(i+4)(j-1)) + -2016 * (u_(i+4)(j)) + 504 * (u_(i+4)(j+2)) + -96 * (u_(i+4)(j+3)) + 9 * (u_(i+4)(j+4))) * (h)**-1 * (h)**-1
  
  PDdissipationNth u_i = 1/1024 * (-252 * (u_) + (u_(i-5)) + -10 * (u_(i-4)) + 45 * (u_(i-3)) + -120 * (u_(i-2)) + 210 * (u_(i-1)) + 210 * (u_(i)) + -120 * (u_(i+2)) + 45 * (u_(i+3)) + -10 * (u_(i+4)) + (u_(i+5))) * (h)**-1
  
  PDupwindNth u_1 = -1/840 * (378 * (u_) + 5 * (u_({1 + -3, 1 +  * , {1 + dir, 1 + @{List[1]}}})) + -60 * (u_({1 + -2, 1 +  * , {1 + dir, 1 + @{List[1]}}})) + 420 * (u_({1 + -1, 1 +  * , {1 + dir, 1 + @{List[1]}}})) + -1050 * (u_({1 + dir, 1 + @{List[1]}})) + 420 * (u_({1 + 2, 1 +  * , {1 + dir, 1 + @{List[1]}}})) + -140 * (u_({1 + 3, 1 +  * , {1 + dir, 1 + @{List[1]}}})) + 30 * (u_({1 + 4, 1 +  * , {1 + dir, 1 + @{List[1]}}})) + -3 * (u_({1 + 5, 1 +  * , {1 + dir, 1 + @{List[1]}}}))) * (h)**-1 * dir@{List[1]}
  
  PDupwindNthAnti u_1 = 1/1680 * (-3 * (u_(1-5)) + 30 * (u_(1-4)) + -145 * (u_(1-3)) + 480 * (u_(1-2)) + -1470 * (u_(1-1)) + 1470 * (u_(1)) + -480 * (u_(1+2)) + 145 * (u_(1+3)) + -30 * (u_(1+4)) + 3 * (u_(1+5))) * (h)**-1
  
  PDupwindNthSymm u_1 = 1/560 * (-252 * (u_) + (u_(1-5)) + -10 * (u_(1-4)) + 45 * (u_(1-3)) + -120 * (u_(1-2)) + 210 * (u_(1-1)) + 210 * (u_(1)) + -120 * (u_(1+2)) + 45 * (u_(1+3)) + -10 * (u_(1+4)) + (u_(1+5))) * (h)**-1
  
  PDonesided u_1 = (-1 * (u_) + (u_({1 + dir, 1 + @{List[1]}}))) * (h)**-1 * dir@{List[1]}
  
  PDupwindNth u_2 = -1/840 * (378 * (u_) + 5 * (u_({2 + -3, 2 +  * , {2 + dir, 2 + @{List[2]}}})) + -60 * (u_({2 + -2, 2 +  * , {2 + dir, 2 + @{List[2]}}})) + 420 * (u_({2 + -1, 2 +  * , {2 + dir, 2 + @{List[2]}}})) + -1050 * (u_({2 + dir, 2 + @{List[2]}})) + 420 * (u_({2 + 2, 2 +  * , {2 + dir, 2 + @{List[2]}}})) + -140 * (u_({2 + 3, 2 +  * , {2 + dir, 2 + @{List[2]}}})) + 30 * (u_({2 + 4, 2 +  * , {2 + dir, 2 + @{List[2]}}})) + -3 * (u_({2 + 5, 2 +  * , {2 + dir, 2 + @{List[2]}}}))) * (h)**-1 * dir@{List[2]}
  
  PDupwindNthAnti u_2 = 1/1680 * (-3 * (u_(2-5)) + 30 * (u_(2-4)) + -145 * (u_(2-3)) + 480 * (u_(2-2)) + -1470 * (u_(2-1)) + 1470 * (u_(2)) + -480 * (u_(2+2)) + 145 * (u_(2+3)) + -30 * (u_(2+4)) + 3 * (u_(2+5))) * (h)**-1
  
  PDupwindNthSymm u_2 = 1/560 * (-252 * (u_) + (u_(2-5)) + -10 * (u_(2-4)) + 45 * (u_(2-3)) + -120 * (u_(2-2)) + 210 * (u_(2-1)) + 210 * (u_(2)) + -120 * (u_(2+2)) + 45 * (u_(2+3)) + -10 * (u_(2+4)) + (u_(2+5))) * (h)**-1
  
  PDonesided u_2 = (-1 * (u_) + (u_({2 + dir, 2 + @{List[2]}}))) * (h)**-1 * dir@{List[2]}
  
  PDupwindNth u_3 = -1/840 * (378 * (u_) + 5 * (u_({3 + -3, 3 +  * , {3 + dir, 3 + @{List[3]}}})) + -60 * (u_({3 + -2, 3 +  * , {3 + dir, 3 + @{List[3]}}})) + 420 * (u_({3 + -1, 3 +  * , {3 + dir, 3 + @{List[3]}}})) + -1050 * (u_({3 + dir, 3 + @{List[3]}})) + 420 * (u_({3 + 2, 3 +  * , {3 + dir, 3 + @{List[3]}}})) + -140 * (u_({3 + 3, 3 +  * , {3 + dir, 3 + @{List[3]}}})) + 30 * (u_({3 + 4, 3 +  * , {3 + dir, 3 + @{List[3]}}})) + -3 * (u_({3 + 5, 3 +  * , {3 + dir, 3 + @{List[3]}}}))) * (h)**-1 * dir@{List[3]}
  
  PDupwindNthAnti u_3 = 1/1680 * (-3 * (u_(3-5)) + 30 * (u_(3-4)) + -145 * (u_(3-3)) + 480 * (u_(3-2)) + -1470 * (u_(3-1)) + 1470 * (u_(3)) + -480 * (u_(3+2)) + 145 * (u_(3+3)) + -30 * (u_(3+4)) + 3 * (u_(3+5))) * (h)**-1
  
  PDupwindNthSymm u_3 = 1/560 * (-252 * (u_) + (u_(3-5)) + -10 * (u_(3-4)) + 45 * (u_(3-3)) + -120 * (u_(3-2)) + 210 * (u_(3-1)) + 210 * (u_(3)) + -120 * (u_(3+2)) + 45 * (u_(3+3)) + -10 * (u_(3+4)) + (u_(3+5))) * (h)**-1
  
  PDonesided u_3 = (-1 * (u_) + (u_({3 + dir, 3 + @{List[3]}}))) * (h)**-1 * dir@{List[3]}
end derivatives

begin variables 
  phi gt_ab Xt^a trK At_ab alpha A beta^a B^a H M_a cS cXt^a cA xCopy yCopy
  zCopy
  rCopy
end variables

begin temporaries 
  detg detgt dottrK e4phi em4phi eta fac1 fac2 rho theta trAt trAts trS cdphi_a
  dir^a dotXt^a epsdiss^a S_a Xtn^a Atm^a_b Ats_ab Atu^ab cdphi2_ab g_ab gtu^ab
  gu^ab R_ab Rphi_ab Rt_ab Gt^a_bc Gtl_abc
  Gtlu_ab^c
end temporaries

begin calculation ML_BSSN_Minkowski scheduled "IN ADMBase_InitialData"
  # ConditionalOnKeyword -> {"my_initial_data", "Minkowski"}
  
  # ExecuteOn -> Host
  
  phi    = (conformalMethod ? 1 :
           0)
  gt_ab  = delta_ab
  trK    = 0
  At_ab  = 0
  Xt^a   = 0
  alpha  = 1
  A      = 0
  beta^a = 0
  B^a    = 0
end calculation

begin calculation ML_BSSN_convertFromADMBase scheduled "AT initial AFTER ADMBase_PostInitial"
  # ConditionalOnKeyword -> {"my_initial_data", "ADMBase"}
  
  # ExecuteOn -> Host
  
  g_ab   = admg_ab
  detg   = -1 * g13**2 * g22 + 2 * g12 * g13 * g23 + -1 * g11 * g23**2 + -1 *
           g12**2 * g33 + g11 * g22 *
           g33
  gu^ab  = detg**-1 * (-1 * g13**2 * g22 + 2 * g12 * g13 * g23 + -1 * g11 *
           g23**2 + -1 * g12**2 * g33 + g11 * g22 * g33) *
           (inverse(g)ab)
  phi    = (conformalMethod ? detg**-1/6 : 1/12 *
           (log(detg)))
  em4phi = (conformalMethod ? phi**2 : E**(-4 *
           phi))
  gt_ab  = em4phi *
           g_ab
  trK    = admK_ab *
           gu^ab
  At_ab  = em4phi * (admK_ab + -1/3 * trK *
           g_ab)
  alpha  = alp
  beta^a = admbeta^a
  xCopy  = x
  yCopy  = y
  zCopy  = z
  rCopy  = r
end calculation

begin calculation ML_BSSN_InitGamma scheduled "AT initial BEFORE ML_BSSN_convertFromADMBaseGamma"
  # ConditionalOnKeyword -> {"my_initial_data", "ADMBase"}
  
  # Where -> Everywhere
  
  # ExecuteOn -> Host
  
  Xt^a = 0
  A    = 0
  B^a  = 0
end calculation

begin calculation ML_BSSN_convertFromADMBaseGamma scheduled "AT initial AFTER ML_BSSN_convertFromADMBase"
  # ConditionalOnKeyword -> {"my_initial_data", "ADMBase"}
  
  # Where -> Interior
  
  # ExecuteOn -> Host
  
  dir^a   = sign(beta^a)
  detgt   = 1
  gtu^ab  = detgt**-1 * (-1 * gt13**2 * gt22 + 2 * gt12 * gt13 * gt23 + -1 *
            gt11 * gt23**2 + -1 * gt12**2 * gt33 + gt11 * gt22 * gt33) *
            (inverse(gt)ab)
  Gt^a_bc = 1/2 * (-1 * (PDstandardNth_d gt_bc) + (PDstandardNth_c gt_bd) +
            (PDstandardNth_b gt_cd)) *
            gtu^ad
  Xt^a    = gtu^bc *
            Gt^a_bc
  A       = (((LapseACoeff)!=(0)) ? -1 * alpha**(-1 * harmonicN) * harmonicF**-1
            * (dtalp + -1 * LapseAdvectionCoeff * ((abs(beta^a)) *
            (PDupwindNthSymm_a alpha) + (PDupwindNthAnti_a alpha) * beta^a)) :
            0)
  theta   = 1
  B^a     = (((ShiftBCoeff * ShiftGammaCoeff)!=(0)) ? ShiftGammaCoeff**-1 *
            theta**-1 * (admdtbeta^a + -1 * ShiftAdvectionCoeff * ((abs(beta^b))
            * (PDupwindNthSymm_b beta^a) + (PDupwindNthAnti_b beta^a) * beta^b))
            :
            0)
end calculation

begin calculation ML_BSSN_RHS scheduled "IN ML_BSSN_evolCalcGroup"
  # Where -> InteriorNoSync
  
  # SplitBy -> {{dot[trK], dot[phi], dot[Tensor[gt, TensorIndex["a", "l"], TensorIndex["b", "l"]]], dot[Tensor[Xt, TensorIndex["i", "u"]]], dot[alpha], dot[A], dot[Tensor[beta, TensorIndex["a", "u"]]], dot[Tensor[B, TensorIndex["a", "u"]]]}, {dot[Tensor[At, TensorIndex["a", "l"], TensorIndex["b", "l"]]]}}
  
  # SeparatedDerivatives -> {PDstandardNth[_, i_] | PDstandardNth[_, i_, i_]}
  
  # SeparatedDerivatives2 -> {PDstandardNth[_, i_, j_] /; i != j}
  
  dir^a        = sign(beta^a)
  detgt        = 1
  gtu^ab       = detgt**-1 * (-1 * gt13**2 * gt22 + 2 * gt12 * gt13 * gt23 + -1
                 * gt11 * gt23**2 + -1 * gt12**2 * gt33 + gt11 * gt22 * gt33) *
                 (inverse(gt)ab)
  Gtl_abc      = 1/2 * ((PDstandardNth_c gt_ba) + -1 * (PDstandardNth_a gt_bc) +
                 (PDstandardNth_b
                 gt_ca))
  Gtlu_ab^c    = gtu^cd *
                 Gtl_abd
  Gt^a_bc      = gtu^ad *
                 Gtl_dbc
  Xtn^i        = gtu^jk *
                 Gt^i_jk
  Rt_ij        = 1/2 * (PDstandardNth_j Xt^k) * gt_ki + 1/2 * (PDstandardNth_i
                 Xt^k) * gt_kj + -1/2 * (PDstandardNth_lm gt_ij) * gtu^lm + 1/2
                 * Xtn^k * Gtl_ijk + 1/2 * Xtn^k * Gtl_jik + Gt^k_jl * Gtlu_ik^l
                 + Gt^k_il * Gtlu_jk^l + Gt^k_il *
                 Gtlu_kj^l
  fac1         = (conformalMethod ? -1/2 * phi**-1 :
                 1)
  cdphi_a      = fac1 * (@{CDt[phi, TensorIndex["a",
                 "l"]]})
  fac2         = (conformalMethod ? 1/2 * phi**-2 :
                 0)
  cdphi2_ab    = fac2 * (@{CDt[phi, TensorIndex["a", "l"]]}) * (@{CDt[phi,
                 TensorIndex["b", "l"]]}) + fac1 * (@{CDt[phi, TensorIndex["a",
                 "l"], TensorIndex["b",
                 "l"]]})
  Rphi_ij      = 4 * cdphi_i * cdphi_j + -2 * cdphi2_ji + -4 * cdphi_l * cdphi_n
                 * gt_ij * gtu^ln + -2 * cdphi2_ln * gt_ij *
                 gtu^ln
  Atm^a_b      = At_cb *
                 gtu^ac
  Atu^ab       = Atm^a_c *
                 gtu^bc
  e4phi        = (conformalMethod ? phi**-2 : E**(4 *
                 phi))
  em4phi       = e4phi**-1
  g_ab         = e4phi *
                 gt_ab
  detg         = -1 * g13**2 * g22 + 2 * g12 * g13 * g23 + -1 * g11 * g23**2 +
                 -1 * g12**2 * g33 + g11 * g22 *
                 g33
  gu^ab        = em4phi *
                 gtu^ab
  R_ab         = Rphi_ab +
                 Rt_ab
  rho          = 0
  S_i          = 0
  trS          = 0
  D_t phi      = alpha * trK * ((conformalMethod ? 1/3 * phi : -1/6)) +
                 ((conformalMethod ? -1/3 * phi : 1/6)) * (PDstandardNth_a
                 beta^a)
  D_t (gt_ab)  = -2 * alpha * At_ab + -2/3 * (PDstandardNth_c beta^c) * gt_ab +
                 (PDstandardNth_b beta^c) * gt_ac + (PDstandardNth_a beta^c) *
                 gt_bc
  dotXt^i      = 2/3 * (PDstandardNth_j beta^j) * Xtn^i + -1 * (PDstandardNth_j
                 beta^i) * Xtn^j + -2 * (PDstandardNth_j alpha) * Atu^ij + 1/3 *
                 (PDstandardNth_jl beta^l) * gtu^ij + (PDstandardNth_jl beta^i)
                 * gtu^jl + 2 * alpha * (6 * cdphi_j * Atu^ij + -2/3 *
                 (PDstandardNth_j trK) * gtu^ij + Atu^kj *
                 Gt^i_jk)
  D_t (Xt^i)   = dotXt^i
  dottrK       = alpha * (1/3 * trK**2 + Atm^a_b * Atm^b_a) + -1 * em4phi * (-1
                 * (PDstandardNth_a alpha) * Xtn^a + ((PDstandardNth_ab alpha) +
                 2 * (PDstandardNth_b alpha) * cdphi_a) *
                 gtu^ab)
  D_t trK      = dottrK
  Ats_ab       = -1 * (@{CDt[alpha, TensorIndex["a", "l"], TensorIndex["b",
                 "l"]]}) + 2 * ((PDstandardNth_b alpha) * cdphi_a +
                 (PDstandardNth_a alpha) * cdphi_b) + alpha *
                 R_ab
  trAts        = Ats_ab *
                 gu^ab
  D_t (At_ab)  = -2/3 * (PDstandardNth_c beta^c) * At_ab + (PDstandardNth_b
                 beta^c) * At_ac + (PDstandardNth_a beta^c) * At_bc + alpha *
                 (trK * At_ab + -2 * At_ac * Atm^c_b) + em4phi * (Ats_ab + -1/3
                 * trAts *
                 g_ab)
  D_t alpha    = -1 * alpha**harmonicN * harmonicF * (A * LapseACoeff + (1 + -1
                 * LapseACoeff) * ((-1 + alpha) * AlphaDriver +
                 trK))
  D_t A        = (-1 * A * AlphaDriver + dottrK) *
                 LapseACoeff
  eta          = 1
  theta        = 1
  D_t (beta^a) = (harmonicShift ? -1/2 * alpha * phi * gtu^aj * (2 * phi *
                 (PDstandardNth_j alpha) + -2 * alpha * (PDstandardNth_j phi) +
                 alpha * phi * (-2 * (PDstandardNth_l gt_jk) + (PDstandardNth_j
                 gt_kl)) * gtu^kl) : ShiftGammaCoeff * theta * (ShiftBCoeff *
                 B^a + (1 + -1 * ShiftBCoeff) * (-1 * BetaDriver * eta * beta^a
                 +
                 Xt^a)))
  D_t (B^a)    = ShiftBCoeff * (-1 * BetaDriver * eta * B^a +
                 dotXt^a)
end calculation

begin calculation ML_BSSN_Advect scheduled "IN ML_BSSN_evolCalcGroup AFTER ML_BSSN_RHS"
  # Where -> InteriorNoSync
  
  # SplitBy -> {dot[trK], dot[phi], dot[Tensor[gt, TensorIndex["a", "l"], TensorIndex["b", "l"]]], dot[Tensor[Xt, TensorIndex["i", "u"]]], dot[alpha], dot[A], dot[Tensor[beta, TensorIndex["a", "u"]]], dot[Tensor[B, TensorIndex["a", "u"]]], dot[Tensor[At, TensorIndex["a", "l"], TensorIndex["b", "l"]]]}
  
  dir^a        = sign(beta^a)
  D_t phi      = (D_t phi) + (abs(beta^a)) * (PDupwindNthSymm_a phi) +
                 (PDupwindNthAnti_a phi) *
                 beta^a
  D_t (gt_ab)  = (D_t (gt_ab)) + (abs(beta^c)) * (PDupwindNthSymm_c gt_ab) +
                 (PDupwindNthAnti_c gt_ab) *
                 beta^c
  D_t (Xt^i)   = (D_t (Xt^i)) + (abs(beta^j)) * (PDupwindNthSymm_j Xt^i) +
                 (PDupwindNthAnti_j Xt^i) *
                 beta^j
  D_t trK      = (D_t trK) + (abs(beta^a)) * (PDupwindNthSymm_a trK) +
                 (PDupwindNthAnti_a trK) *
                 beta^a
  D_t (At_ab)  = (D_t (At_ab)) + (abs(beta^c)) * (PDupwindNthSymm_c At_ab) +
                 (PDupwindNthAnti_c At_ab) *
                 beta^c
  D_t alpha    = (D_t alpha) + LapseAdvectionCoeff * ((abs(beta^a)) *
                 (PDupwindNthSymm_a alpha) + (PDupwindNthAnti_a alpha) *
                 beta^a)
  D_t A        = (D_t A) + LapseACoeff * (LapseAdvectionCoeff * ((abs(beta^a)) *
                 (PDupwindNthSymm_a A) + (PDupwindNthAnti_a A) * beta^a) + (1 +
                 -1 * LapseAdvectionCoeff) * ((abs(beta^a)) * (PDupwindNthSymm_a
                 trK) + (PDupwindNthAnti_a trK) *
                 beta^a))
  D_t (beta^a) = (D_t (beta^a)) + ShiftAdvectionCoeff * ((abs(beta^b)) *
                 (PDupwindNthSymm_b beta^a) + (PDupwindNthAnti_b beta^a) *
                 beta^b)
  D_t (B^a)    = (D_t (B^a)) + ShiftBCoeff * (ShiftAdvectionCoeff *
                 ((abs(beta^b)) * (PDupwindNthSymm_b B^a) + (PDupwindNthAnti_b
                 B^a) * beta^b) + (1 + -1 * ShiftAdvectionCoeff) *
                 ((abs(beta^b)) * (PDupwindNthSymm_b Xt^a) + (PDupwindNthAnti_b
                 Xt^a) *
                 beta^b))
end calculation

begin calculation ML_BSSN_InitRHS scheduled "AT analysis BEFORE ML_BSSN_evolCalcGroup"
  # Where -> Everywhere
  
  D_t phi      = 0
  D_t (gt_ab)  = 0
  D_t trK      = 0
  D_t (At_ab)  = 0
  D_t (Xt^a)   = 0
  D_t alpha    = 0
  D_t A        = 0
  D_t (beta^a) = 0
  D_t (B^a)    = 0
end calculation

begin calculation ML_BSSN_RHSStaticBoundary scheduled "IN ML_BSSN_evolCalcGroup"
  # ConditionalOnKeyword -> {"my_rhs_boundary_condition", "static"}
  
  # Where -> BoundaryWithGhosts
  
  D_t phi      = 0
  D_t (gt_ab)  = 0
  D_t trK      = 0
  D_t (At_ab)  = 0
  D_t (Xt^a)   = 0
  D_t alpha    = 0
  D_t A        = 0
  D_t (beta^a) = 0
  D_t (B^a)    = 0
end calculation

begin calculation ML_BSSN_enforce scheduled "IN MoL_PostStepModify"
  detgt  = 1
  gtu^ab = detgt**-1 * (-1 * gt13**2 * gt22 + 2 * gt12 * gt13 * gt23 + -1 * gt11
           * gt23**2 + -1 * gt12**2 * gt33 + gt11 * gt22 * gt33) *
           (inverse(gt)ab)
  trAt   = At_ab *
           gtu^ab
  At_ab  = At_ab + -1/3 * trAt *
           gt_ab
  alpha  = max(alpha,MinimumLapse)
end calculation

begin calculation ML_BSSN_convertToADMBase scheduled "IN ML_BSSN_convertToADMBaseGroup"
  # ConditionalOnKeyword -> {"calculate_ADMBase_variables", "yes"}
  
  # Where -> Everywhere
  
  e4phi     = (conformalMethod ? phi**-2 : E**(4 *
              phi))
  admg_ab   = e4phi *
              gt_ab
  admK_ab   = e4phi * At_ab + 1/3 * e4phi * trK *
              gt_ab
  alp       = alpha
  admbeta^a = beta^a
end calculation

begin calculation ML_BSSN_copy_to_device scheduled "at INITIAL after ML_BSSN_convertFromADMBaseGamma"
  # Where -> Everywhere
  
  phi    = phi
  gt_ab  = gt_ab
  Xt^i   = Xt^i
  trK    = trK
  At_ab  = At_ab
  alpha  = alpha
  A      = A
  beta^a = beta^a
  B^a    = B^a
end calculation


end thorn
