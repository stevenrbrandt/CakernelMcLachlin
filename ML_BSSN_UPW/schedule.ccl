# File produced by Kranc


STORAGE: ML_cons_detg[1]

STORAGE: ML_cons_Gamma[1]

STORAGE: ML_cons_traceA[1]

STORAGE: ML_Ham[1]

STORAGE: ML_mom[1]

if (timelevels == 1)
{
  STORAGE: ML_curv[1]
}
if (timelevels == 2)
{
  STORAGE: ML_curv[2]
}
if (timelevels == 3)
{
  STORAGE: ML_curv[3]
}

if (timelevels == 1)
{
  STORAGE: ML_dtlapse[1]
}
if (timelevels == 2)
{
  STORAGE: ML_dtlapse[2]
}
if (timelevels == 3)
{
  STORAGE: ML_dtlapse[3]
}

if (timelevels == 1)
{
  STORAGE: ML_dtshift[1]
}
if (timelevels == 2)
{
  STORAGE: ML_dtshift[2]
}
if (timelevels == 3)
{
  STORAGE: ML_dtshift[3]
}

if (timelevels == 1)
{
  STORAGE: ML_Gamma[1]
}
if (timelevels == 2)
{
  STORAGE: ML_Gamma[2]
}
if (timelevels == 3)
{
  STORAGE: ML_Gamma[3]
}

if (timelevels == 1)
{
  STORAGE: ML_lapse[1]
}
if (timelevels == 2)
{
  STORAGE: ML_lapse[2]
}
if (timelevels == 3)
{
  STORAGE: ML_lapse[3]
}

if (timelevels == 1)
{
  STORAGE: ML_log_confac[1]
}
if (timelevels == 2)
{
  STORAGE: ML_log_confac[2]
}
if (timelevels == 3)
{
  STORAGE: ML_log_confac[3]
}

if (timelevels == 1)
{
  STORAGE: ML_metric[1]
}
if (timelevels == 2)
{
  STORAGE: ML_metric[2]
}
if (timelevels == 3)
{
  STORAGE: ML_metric[3]
}

if (timelevels == 1)
{
  STORAGE: ML_shift[1]
}
if (timelevels == 2)
{
  STORAGE: ML_shift[2]
}
if (timelevels == 3)
{
  STORAGE: ML_shift[3]
}

if (timelevels == 1)
{
  STORAGE: ML_trace_curv[1]
}
if (timelevels == 2)
{
  STORAGE: ML_trace_curv[2]
}
if (timelevels == 3)
{
  STORAGE: ML_trace_curv[3]
}

if (rhs_timelevels == 1)
{
  STORAGE: ML_curvrhs[1]
}
if (rhs_timelevels == 2)
{
  STORAGE: ML_curvrhs[2]
}
if (rhs_timelevels == 3)
{
  STORAGE: ML_curvrhs[3]
}

if (rhs_timelevels == 1)
{
  STORAGE: ML_dtlapserhs[1]
}
if (rhs_timelevels == 2)
{
  STORAGE: ML_dtlapserhs[2]
}
if (rhs_timelevels == 3)
{
  STORAGE: ML_dtlapserhs[3]
}

if (rhs_timelevels == 1)
{
  STORAGE: ML_dtshiftrhs[1]
}
if (rhs_timelevels == 2)
{
  STORAGE: ML_dtshiftrhs[2]
}
if (rhs_timelevels == 3)
{
  STORAGE: ML_dtshiftrhs[3]
}

if (rhs_timelevels == 1)
{
  STORAGE: ML_Gammarhs[1]
}
if (rhs_timelevels == 2)
{
  STORAGE: ML_Gammarhs[2]
}
if (rhs_timelevels == 3)
{
  STORAGE: ML_Gammarhs[3]
}

if (rhs_timelevels == 1)
{
  STORAGE: ML_lapserhs[1]
}
if (rhs_timelevels == 2)
{
  STORAGE: ML_lapserhs[2]
}
if (rhs_timelevels == 3)
{
  STORAGE: ML_lapserhs[3]
}

if (rhs_timelevels == 1)
{
  STORAGE: ML_log_confacrhs[1]
}
if (rhs_timelevels == 2)
{
  STORAGE: ML_log_confacrhs[2]
}
if (rhs_timelevels == 3)
{
  STORAGE: ML_log_confacrhs[3]
}

if (rhs_timelevels == 1)
{
  STORAGE: ML_metricrhs[1]
}
if (rhs_timelevels == 2)
{
  STORAGE: ML_metricrhs[2]
}
if (rhs_timelevels == 3)
{
  STORAGE: ML_metricrhs[3]
}

if (rhs_timelevels == 1)
{
  STORAGE: ML_shiftrhs[1]
}
if (rhs_timelevels == 2)
{
  STORAGE: ML_shiftrhs[2]
}
if (rhs_timelevels == 3)
{
  STORAGE: ML_shiftrhs[3]
}

if (rhs_timelevels == 1)
{
  STORAGE: ML_trace_curvrhs[1]
}
if (rhs_timelevels == 2)
{
  STORAGE: ML_trace_curvrhs[2]
}
if (rhs_timelevels == 3)
{
  STORAGE: ML_trace_curvrhs[3]
}

schedule ML_BSSN_UPW_Startup at STARTUP
{
  LANG: C
  OPTIONS: meta
} "create banner"

schedule ML_BSSN_UPW_RegisterVars in MoL_Register
{
  LANG: C
  OPTIONS: meta
} "Register Variables for MoL"

schedule ML_BSSN_UPW_RegisterSymmetries in SymmetryRegister
{
  LANG: C
  OPTIONS: meta
} "register symmetries"


if (CCTK_EQUALS(my_initial_data, "Minkowski"))
{
  schedule ML_BSSN_UPW_Minkowski IN ADMBase_InitialData
  {
    LANG: C
  } "ML_BSSN_UPW_Minkowski"
}


if (CCTK_EQUALS(my_initial_data, "ADMBase"))
{
  schedule ML_BSSN_UPW_convertFromADMBase AT initial AFTER ADMBase_PostInitial
  {
    LANG: C
  } "ML_BSSN_UPW_convertFromADMBase"
}


if (CCTK_EQUALS(my_initial_data, "ADMBase"))
{
  schedule ML_BSSN_UPW_InitGamma AT initial BEFORE ML_BSSN_UPW_convertFromADMBaseGamma
  {
    LANG: C
  } "ML_BSSN_UPW_InitGamma"
}


if (CCTK_EQUALS(my_initial_data, "ADMBase"))
{
  schedule ML_BSSN_UPW_convertFromADMBaseGamma AT initial AFTER ML_BSSN_UPW_convertFromADMBase
  {
    LANG: C
    SYNC: ML_dtlapse
    SYNC: ML_dtshift
    SYNC: ML_Gamma
  } "ML_BSSN_UPW_convertFromADMBaseGamma"
}

schedule ML_BSSN_UPW_RHS1 IN ML_BSSN_UPW_evolCalcGroup
{
  LANG: C
} "ML_BSSN_UPW_RHS1"

schedule ML_BSSN_UPW_RHS2 IN ML_BSSN_UPW_evolCalcGroup
{
  LANG: C
} "ML_BSSN_UPW_RHS2"


if (CCTK_EQUALS(apply_dissipation, "always"))
{
  schedule ML_BSSN_UPW_Dissipation IN ML_BSSN_UPW_evolCalcGroup after ML_BSSN_UPW_RHS2
  {
    LANG: C
  } "ML_BSSN_UPW_Dissipation"
}

schedule ML_BSSN_UPW_Advect IN ML_BSSN_UPW_evolCalcGroup after ML_BSSN_UPW_RHS2
{
  LANG: C
} "ML_BSSN_UPW_Advect"


if (CCTK_EQUALS(my_rhs_boundary_condition, "static"))
{
  schedule ML_BSSN_UPW_RHSStaticBoundary IN MoL_CalcRHS
  {
    LANG: C
  } "ML_BSSN_UPW_RHSStaticBoundary"
}

schedule ML_BSSN_UPW_enforce IN MoL_PostStep BEFORE ML_BSSN_UPW_SelectBoundConds
{
  LANG: C
} "ML_BSSN_UPW_enforce"


if (CCTK_EQUALS(my_boundary_condition, "Minkowski"))
{
  schedule ML_BSSN_UPW_boundary IN MoL_PostStep
  {
    LANG: C
  } "ML_BSSN_UPW_boundary"
}

schedule ML_BSSN_UPW_convertToADMBase IN ML_BSSN_UPW_convertToADMBaseGroup
{
  LANG: C
} "ML_BSSN_UPW_convertToADMBase"


if (CCTK_EQUALS(dt_lapse_shift_method, "correct"))
{
  schedule ML_BSSN_UPW_convertToADMBaseDtLapseShift IN ML_BSSN_UPW_convertToADMBaseGroup
  {
    LANG: C
    SYNC: ADMBase::dtlapse
    SYNC: ADMBase::dtshift
  } "ML_BSSN_UPW_convertToADMBaseDtLapseShift"
}


if (CCTK_EQUALS(dt_lapse_shift_method, "correct"))
{
  schedule ML_BSSN_UPW_convertToADMBaseDtLapseShiftBoundary IN ML_BSSN_UPW_convertToADMBaseGroup
  {
    LANG: C
  } "ML_BSSN_UPW_convertToADMBaseDtLapseShiftBoundary"
}


if (CCTK_EQUALS(dt_lapse_shift_method, "noLapseShiftAdvection"))
{
  schedule ML_BSSN_UPW_convertToADMBaseFakeDtLapseShift IN ML_BSSN_UPW_convertToADMBaseGroup
  {
    LANG: C
  } "ML_BSSN_UPW_convertToADMBaseFakeDtLapseShift"
}

schedule group ML_BSSN_UPW_constraints1_group in MoL_PseudoEvolution
{
  # no language specified
} "ML_BSSN_UPW_constraints1"

schedule ML_BSSN_UPW_constraints1 in ML_BSSN_UPW_constraints1_group
{
  LANG: C
} "ML_BSSN_UPW_constraints1"

schedule ML_BSSN_UPW_constraints1_SelectBCs in ML_BSSN_UPW_constraints1_bc_group
{
  LANG: C
  OPTIONS: level
  SYNC: ML_Ham
} "ML_BSSN_UPW_constraints1_SelectBCs"

schedule group ApplyBCs as ML_BSSN_UPW_constraints1_ApplyBCs in ML_BSSN_UPW_constraints1_bc_group after ML_BSSN_UPW_constraints1_SelectBCs
{
  # no language specified
} "Apply BCs for groups set in ML_BSSN_UPW_constraints1"

schedule group ML_BSSN_UPW_constraints1_bc_group in ML_BSSN_UPW_constraints1_group after ML_BSSN_UPW_constraints1
{
  # no language specified
} "ML_BSSN_UPW_constraints1"

schedule group ML_BSSN_UPW_constraints1_bc_group at CCTK_POSTRESTRICT
{
  # no language specified
} "ML_BSSN_UPW_constraints1"

schedule group ML_BSSN_UPW_constraints1_bc_group at CCTK_POSTRESTRICTINITIAL
{
  # no language specified
} "ML_BSSN_UPW_constraints1"

schedule group ML_BSSN_UPW_constraints2_group in MoL_PseudoEvolution
{
  # no language specified
} "ML_BSSN_UPW_constraints2"

schedule ML_BSSN_UPW_constraints2 in ML_BSSN_UPW_constraints2_group
{
  LANG: C
} "ML_BSSN_UPW_constraints2"

schedule ML_BSSN_UPW_constraints2_SelectBCs in ML_BSSN_UPW_constraints2_bc_group
{
  LANG: C
  OPTIONS: level
  SYNC: ML_cons_detg
  SYNC: ML_cons_Gamma
  SYNC: ML_cons_traceA
  SYNC: ML_mom
} "ML_BSSN_UPW_constraints2_SelectBCs"

schedule group ApplyBCs as ML_BSSN_UPW_constraints2_ApplyBCs in ML_BSSN_UPW_constraints2_bc_group after ML_BSSN_UPW_constraints2_SelectBCs
{
  # no language specified
} "Apply BCs for groups set in ML_BSSN_UPW_constraints2"

schedule group ML_BSSN_UPW_constraints2_bc_group in ML_BSSN_UPW_constraints2_group after ML_BSSN_UPW_constraints2
{
  # no language specified
} "ML_BSSN_UPW_constraints2"

schedule group ML_BSSN_UPW_constraints2_bc_group at CCTK_POSTRESTRICT
{
  # no language specified
} "ML_BSSN_UPW_constraints2"

schedule group ML_BSSN_UPW_constraints2_bc_group at CCTK_POSTRESTRICTINITIAL
{
  # no language specified
} "ML_BSSN_UPW_constraints2"

schedule ML_BSSN_UPW_SelectBoundConds in MoL_PostStep
{
  LANG: C
  OPTIONS: level
  SYNC: ML_curv
  SYNC: ML_dtlapse
  SYNC: ML_dtshift
  SYNC: ML_Gamma
  SYNC: ML_lapse
  SYNC: ML_log_confac
  SYNC: ML_metric
  SYNC: ML_shift
  SYNC: ML_trace_curv
} "select boundary conditions"

schedule ML_BSSN_UPW_CheckBoundaries at BASEGRID
{
  LANG: C
  OPTIONS: meta
} "check boundaries treatment"

schedule group ApplyBCs as ML_BSSN_UPW_ApplyBCs in MoL_PostStep after ML_BSSN_UPW_SelectBoundConds
{
  # no language specified
} "Apply boundary conditions controlled by thorn Boundary"
